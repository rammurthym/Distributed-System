/**
 * @author  Rammurthy Mudimadugula
 * @netid   rxm163730
 * @version 1.0
 * @since   2016-09-22
 *
 * CS6370 - Advanced Operating Systems - Project #1
 */

import java.io.*;
import java.net.*;
import java.nio.*;
import java.util.*;

// import com.sun.nio.sctp.*;

/**
 * Multi Threaded Server class handles threads created by the server for the
 * incoming sockets.
 */

public class MultiThreadedServer implements Runnable {
    /**
     * Private variables related to MultiThreadedServer class.
     * @variable label         Label value of the node.
     * @variable identifier    ID of the node.
     * @variable serverToken   Token which is forwarded to this node.
     * @variable clientSocket  Socket sent by the previous node in network path.
     * @variable allNodes      Details of the each node in the network.
     * @variable runningThread Variable to store current running thread.
     * @variable isStopped     Boolean variable to check status of the server.
     */

    private int label;
    private int identifier;
    private Socket clientSocket;
    private Token serverToken;
    private boolean isStopped = false;
    private Thread runningThread = null;
    private HashMap<Integer, String> allNodes = new LinkedHashMap<Integer, String>();

    /**
     * Class method to instantiate the Start class.
     * @param  id       ID of the node.
     * @param  label    Random number generated by the incoming socket node.
     * @param  client   Client socket sent by the previous node in the path.
     * @param  allNodes Hashmap to store details of all nodes. 
     * @return null Nothing.
     */
    public MultiThreadedServer(Socket client, int label, int id, HashMap<Integer, String> allNodes) {
        this.clientSocket = client;
        this.label = label;
        this.identifier = id;
        this.allNodes = allNodes;
    }

    /**
     * 
     */
    private synchronized boolean isStopped() {
        return this.isStopped;
    }

    /**
     * 
     */
    public synchronized void stop() {
        this.isStopped = true;
        try {
            this.runningThread.interrupt();
            this.clientSocket.close();
        } catch (IOException e) {
            throw new RuntimeException("MultiThreadedServer: stop: Error closing server", e);
        }
    }

    // public synchronized void update() {
    //     Node.numOfCompleteMsgs += 1;
    // }

    /**
     * Run method starts when start method is called on MultiThreadedServer class.
     * Accepts the incoming token and process them. If the path is left to be
     * traversed, forwards the socket to next node or else prints the ID and
     * Label values to a unique file.
     * 
     * @exception IOException
     * @exception ClassNotFoundException
     * @return Nothing.
     */
    @Override
    public void run() {
        synchronized(this) {
            this.runningThread = Thread.currentThread();
        }
        try {
            ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());
            // MessageInfo messageInfo = sctpChannel.receive(ByteBuffer.allocate(64000) , null, null); 

            this.serverToken = (Token) in.readObject();
            // this.serverToken = (Token) messageInfo;
            processToken();
            // if (isStopped()) {
            //     runningThread.interrupt();
            //     return;
            // }
        } catch (IOException e) {
            System.out.println("MultiThreadedServer: run: IOException: " + e);
            System.exit(1);
        } catch (ClassNotFoundException ex) {
            System.out.println("MultiThreadedServer: run: ClassNotFoundException: " + ex);
            System.exit(1);
        }
    }

    /**
     * Method to process the incoming token. Checks whether the socket traversal
     * is complete or not. If not completed, updates the token with new values.
     *
     * @return Nothing.
     */
    public void processToken() throws IOException {
        if (this.serverToken.getStatus() == "COMPLETE") {
            Node.update();
            System.out.println("Number of complete messages received: " + Node.numOfCompleteMsgs);
            if (Node.get() == (this.allNodes.size() - 1)) {
                System.out.println("Received COMPLETE message token from all nodes");
                stop();
            }
        } else {
            String path = this.serverToken.getPath();
            System.out.println("132: " + path + " nocm: " + Node.numOfCompleteMsgs);
            if (path.length() == 1 && this.identifier == Integer.parseInt(path)) {
                createFile(serverToken.getSum());
                sendCompleteMsg();
                // this.runningThread.interrupt();
            } else {
                String newPath = (path.length() > 2) ? path.substring(2) : path;
                serverToken.updatePath(newPath);
                serverToken.computeLabel(this.label);
                Client nextClient = new Client(this.serverToken, this.allNodes);
                new Thread(nextClient).start();
                // this.runningThread.interrupt();
            }
        }
    }

    /**
     * 
     */
    private void sendCompleteMsg() {
        for (Integer key : this.allNodes.keySet()) {
            if (this.identifier != key) {
                String[] clientDetails = this.allNodes.get(key).split(",");
                Token statusToken = new Token(this.identifier,
                    Integer.toString(key),
                    this.label, Integer.toString(key));
                statusToken.setStatus("COMPLETE");
                Client newClient = new Client(statusToken, this.allNodes);
                new Thread(newClient).start();
            }
        }
    }

    /**
     * Method to create file and write ID and Label values to it.
     *
     * @param  sum Sum of the label values computed by the socket traversal.
     * @return Nothing
     */
    private void createFile(int sum) throws IOException {
        File newFile = new File("rxm163730:" + this.identifier + ".out");
        File file = new File("rxm163730:" + this.identifier + ".out");
        FileWriter fileWriter = new FileWriter(file);
        fileWriter.write("Label: " + this.label + "\n");
        fileWriter.write("Sum of labels: " + sum + "\n");
        fileWriter.flush();
        fileWriter.close();
    }
}
